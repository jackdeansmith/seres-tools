#include "sequence.hpp"
#include "walk.hpp"
#include "resample.hpp"
#include <stdexcept> 
using std::out_of_range; 
#include <utility>
using std::make_pair;
#include <random>
using std::mt19937_64;
using std::uniform_int_distribution; using std::bernoulli_distribution;
using std::geometric_distribution;
#include <vector>
using std::vector;

//Convinience function which gives us a random direction, left or right with
//equal probability.
Direction RandomDirection(mt19937_64& rng){
    bernoulli_distribution heads_or_tails(0.5);
    if(heads_or_tails(rng)){
        return Direction::Right;    
    }
    else{
        return Direction::Left; 
    }
}

//Get a vector of lengths all generated by a geometric process such that their
//sum is equal to a given parameter. Lengths of 0 are ignored and the last
//length may be trimmed to make the total work out.
vector<size_t> GetGeometricLengths(size_t total, double prob, mt19937_64& rng){
    //Empty vector and geometric distribuiton are created
    vector<size_t> result;
    geometric_distribution<size_t> length_dist(prob);

    //While the remaining lenth is still positive
    while(total > 0){

        //Generate a new length and trim it if need be
        size_t next_length = length_dist(rng);
        if(next_length > total){
            next_length = total; 
        }

        //If the length isn't 0, then push it back and subtract from total
        if(next_length != 0){
            total -= next_length;
            result.push_back(next_length);
        }
    }

    return result;
}

//Get the length before the resampler runs into a wall
size_t LengthBeforeEnd(size_t position, size_t input_length, Direction direction){
    if(direction == Direction::Right){
        return input_length - position;    
    }
    else{
        return position + 1; 
    }
}

//Accepts a sequence of lengths, start position and direction, and the input
//length and constructs a random walk object.
RandomWalk LengthsToWalk(const vector<size_t>& lengths, size_t position, 
                         Direction direction, size_t input_length){
    RandomWalk result;
    for (size_t length : lengths){
        while(length > 0){

            //Get the next segment length
            size_t length_before_end = 
                LengthBeforeEnd(position, input_length, direction);
            size_t next_segment_length;          
            if(length < length_before_end){
                next_segment_length = length; 
                length = 0;
            }
            else{
                next_segment_length = length_before_end; 
                length -= length_before_end;
            }

            //Add the next segment and move the position as appropriate
            result.add(position, next_segment_length, direction);
            if(direction == Direction::Right){
                position += next_segment_length - 1; 
            }
            else{
                position -= next_segment_length - 1; 
            }

            //Now move one position backwards and reverse direction
            if(direction == Direction::Left){
                position++; 
            }
            else{
                position--; 
            }
            direction = ReverseDirection(direction);
        }
    }
    return result;
}


RandomWalk GenerateRandomWalk(size_t input_length, size_t output_length, 
                              double turnaround_bias, mt19937_64& rng){

    //Generate a random starting position and direction
    Direction start_direction = RandomDirection(rng);
    uniform_int_distribution<size_t> start_dist(0, input_length);
    size_t start_position = start_dist(rng);

    //Generate the vector of geometrically distributed lengths
    vector<size_t> geometric_lengths = 
        GetGeometricLengths(output_length, turnaround_bias, rng);

    //Farm off the rest to the LengthsToWalk function
    return LengthsToWalk(geometric_lengths, start_position, 
                         start_direction, input_length);
}

//Convinience function which copies a column from one char matrix to another,
//this is MEMORY UNSAFE and will fail in bad ways if you give it bad indicies!
void CopyColumn(const CharMatrix& from, size_t from_col, 
                      CharMatrix& to, size_t to_col){
    for(size_t row_index = 0; row_index < to.height(); row_index++){
        char c = from.get(row_index, from_col);
        to.set(row_index, to_col, c);
    }
}

//Function which accepts a filled in original matrix and an incomplete replicate
//matrix. The function copies columns from the original to the replicate in
//order to match the walk provided by the given ReplicateWalk object.
void CopyWalkSegment(const CharMatrix& from, CharMatrix& to, 
                     const WalkSegment& seg){

    size_t original_index = seg.original_pos;
    size_t replicate_index = seg.replicate_pos;
    for(size_t i = 0; i < seg.length; i++){
        CopyColumn(from, original_index, to, replicate_index);

        replicate_index++;
        if(seg.direction == Direction::Right){
            original_index++;
        }
        else{
            original_index--; 
        }
    }
}

//TODO comment
CharMatrix Resample(const CharMatrix& input_matrix, const RandomWalk& walk){
    //Allocate a new matrix
    CharMatrix output_matrix(input_matrix.height(), walk.length());

    //Iterate through all segments in order
    for (WalkSegment segment: walk){
       CopyWalkSegment(input_matrix, output_matrix, segment); 
    }

    return output_matrix;
}

